# Autogenerated using ProtoBuf.jl v1.0.7 on 2022-10-11T13:52:28.327
# original file: /Users/arhik/October2022/IPFS.jl/src/protos/bitswap.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using EnumX: @enumx

export var"Message.Block", var"Message.BlockPresenceType", var"Message.Wantlist.WantType"
export var"Message.BlockPresence", var"Message.Wantlist.Entry", var"Message.Wantlist"
export Message

struct var"Message.Block"
    prefix::Vector{UInt8}
    data::Vector{UInt8}
end
PB.default_values(::Type{var"Message.Block"}) = (;prefix = UInt8[], data = UInt8[])
PB.field_numbers(::Type{var"Message.Block"}) = (;prefix = 1, data = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Message.Block"})
    prefix = UInt8[]
    data = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            prefix = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            data = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Message.Block"(prefix, data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Message.Block")
    initpos = position(e.io)
    !isempty(x.prefix) && PB.encode(e, 1, x.prefix)
    !isempty(x.data) && PB.encode(e, 2, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Message.Block")
    encoded_size = 0
    !isempty(x.prefix) && (encoded_size += PB._encoded_size(x.prefix, 1))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 2))
    return encoded_size
end

@enumx var"Message.BlockPresenceType" Have=0 DontHave=1

@enumx var"Message.Wantlist.WantType" Block=0 Have=1

struct var"Message.BlockPresence"
    cid::Vector{UInt8}
    var"#type"::var"Message.BlockPresenceType".T
end
PB.default_values(::Type{var"Message.BlockPresence"}) = (;cid = UInt8[], var"#type" = var"Message.BlockPresenceType".Have)
PB.field_numbers(::Type{var"Message.BlockPresence"}) = (;cid = 1, var"#type" = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Message.BlockPresence"})
    cid = UInt8[]
    var"#type" = var"Message.BlockPresenceType".Have
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            cid = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            var"#type" = PB.decode(d, var"Message.BlockPresenceType".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Message.BlockPresence"(cid, var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Message.BlockPresence")
    initpos = position(e.io)
    !isempty(x.cid) && PB.encode(e, 1, x.cid)
    x.var"#type" != var"Message.BlockPresenceType".Have && PB.encode(e, 2, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Message.BlockPresence")
    encoded_size = 0
    !isempty(x.cid) && (encoded_size += PB._encoded_size(x.cid, 1))
    x.var"#type" != var"Message.BlockPresenceType".Have && (encoded_size += PB._encoded_size(x.var"#type", 2))
    return encoded_size
end

struct var"Message.Wantlist.Entry"
    block::Vector{UInt8}
    priority::Int32
    cancel::Bool
    wantType::var"Message.Wantlist.WantType".T
    sendDontHave::Bool
end
PB.default_values(::Type{var"Message.Wantlist.Entry"}) = (;block = UInt8[], priority = zero(Int32), cancel = false, wantType = var"Message.Wantlist.WantType".Block, sendDontHave = false)
PB.field_numbers(::Type{var"Message.Wantlist.Entry"}) = (;block = 1, priority = 2, cancel = 3, wantType = 4, sendDontHave = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Message.Wantlist.Entry"})
    block = UInt8[]
    priority = zero(Int32)
    cancel = false
    wantType = var"Message.Wantlist.WantType".Block
    sendDontHave = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            block = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            priority = PB.decode(d, Int32)
        elseif field_number == 3
            cancel = PB.decode(d, Bool)
        elseif field_number == 4
            wantType = PB.decode(d, var"Message.Wantlist.WantType".T)
        elseif field_number == 5
            sendDontHave = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Message.Wantlist.Entry"(block, priority, cancel, wantType, sendDontHave)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Message.Wantlist.Entry")
    initpos = position(e.io)
    !isempty(x.block) && PB.encode(e, 1, x.block)
    x.priority != zero(Int32) && PB.encode(e, 2, x.priority)
    x.cancel != false && PB.encode(e, 3, x.cancel)
    x.wantType != var"Message.Wantlist.WantType".Block && PB.encode(e, 4, x.wantType)
    x.sendDontHave != false && PB.encode(e, 5, x.sendDontHave)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Message.Wantlist.Entry")
    encoded_size = 0
    !isempty(x.block) && (encoded_size += PB._encoded_size(x.block, 1))
    x.priority != zero(Int32) && (encoded_size += PB._encoded_size(x.priority, 2))
    x.cancel != false && (encoded_size += PB._encoded_size(x.cancel, 3))
    x.wantType != var"Message.Wantlist.WantType".Block && (encoded_size += PB._encoded_size(x.wantType, 4))
    x.sendDontHave != false && (encoded_size += PB._encoded_size(x.sendDontHave, 5))
    return encoded_size
end

struct var"Message.Wantlist"
    entries::Vector{var"Message.Wantlist.Entry"}
    full::Bool
end
PB.default_values(::Type{var"Message.Wantlist"}) = (;entries = Vector{var"Message.Wantlist.Entry"}(), full = false)
PB.field_numbers(::Type{var"Message.Wantlist"}) = (;entries = 1, full = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Message.Wantlist"})
    entries = PB.BufferedVector{var"Message.Wantlist.Entry"}()
    full = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, entries)
        elseif field_number == 2
            full = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Message.Wantlist"(entries[], full)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Message.Wantlist")
    initpos = position(e.io)
    !isempty(x.entries) &&   			for el in x.entries
    			PB.encode(e, 1, el)
 		   	end
	    
    x.full != false && PB.encode(e, 2, x.full)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Message.Wantlist")
    encoded_size = 0
    !isempty(x.entries) && (encoded_size += PB._encoded_size(x.entries, 1))
    x.full != false && (encoded_size += PB._encoded_size(x.full, 2))
    return encoded_size
end

struct Message
    wantlist::Union{Nothing,var"Message.Wantlist"}
    blocks::Vector{Vector{UInt8}}
    payload::Vector{var"Message.Block"}
    blockPresences::Vector{var"Message.BlockPresence"}
    pendingBytes::Int32
end
PB.default_values(::Type{Message}) = (;wantlist = nothing, blocks = Vector{Vector{UInt8}}(), payload = Vector{var"Message.Block"}(), blockPresences = Vector{var"Message.BlockPresence"}(), pendingBytes = zero(Int32))
PB.field_numbers(::Type{Message}) = (;wantlist = 1, blocks = 2, payload = 3, blockPresences = 4, pendingBytes = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Message})
    wantlist = Ref{Union{Nothing,var"Message.Wantlist"}}(nothing)
    blocks = PB.BufferedVector{Vector{UInt8}}()
    payload = PB.BufferedVector{var"Message.Block"}()
    blockPresences = PB.BufferedVector{var"Message.BlockPresence"}()
    pendingBytes = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wantlist)
        elseif field_number == 2
            PB.decode!(d, blocks)
        elseif field_number == 3
            PB.decode!(d, payload)
        elseif field_number == 4
            PB.decode!(d, blockPresences)
        elseif field_number == 5
            pendingBytes = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Message(wantlist[], blocks[], payload[], blockPresences[], pendingBytes)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Message)
    initpos = position(e.io)
    !isnothing(x.wantlist) && PB.encode(e, 1, x.wantlist)
    !isempty(x.blocks) &&   			for el in x.blocks
    			PB.encode(e, 2, el)
 		   	end
	    
    !isempty(x.payload) &&   			for el in x.payload
    			PB.encode(e, 3, el)
 		   	end
	    
    !isempty(x.blockPresences) &&   			for el in x.blockPresences
    			PB.encode(e, 4, el)
 		   	end
	    
    x.pendingBytes != zero(Int32) && PB.encode(e, 5, x.pendingBytes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Message)
    encoded_size = 0
    !isnothing(x.wantlist) && (encoded_size += PB._encoded_size(x.wantlist, 1))
    !isempty(x.blocks) && (encoded_size += PB._encoded_size(x.blocks, 2))
    !isempty(x.payload) && (encoded_size += PB._encoded_size(x.payload, 3))
    !isempty(x.blockPresences) && (encoded_size += PB._encoded_size(x.blockPresences, 4))
    x.pendingBytes != zero(Int32) && (encoded_size += PB._encoded_size(x.pendingBytes, 5))
    return encoded_size
end
