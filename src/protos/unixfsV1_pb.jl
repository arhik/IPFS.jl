# Autogenerated using ProtoBuf.jl v1.0.7 on 2022-10-06T15:05:37.925
# original file: /Users/arhik/October2022/IPFS.jl/src/unixfsV1.proto (proto2 syntax)

module unixfsV1_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using EnumX: @enumx

export var"Data.DataType", Metadata, UnixTime, Data

@enumx var"Data.DataType" Raw=0 Directory=1 File=2 Metadata=3 Symlink=4 HAMTShard=5

struct Metadata
    MimeType::String
end
PB.default_values(::Type{Metadata}) = (;MimeType = "")
PB.field_numbers(::Type{Metadata}) = (;MimeType = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Metadata})
    MimeType = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            MimeType = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Metadata(MimeType)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Metadata)
    initpos = position(e.io)
    !isempty(x.MimeType) && PB.encode(e, 1, x.MimeType)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Metadata)
    encoded_size = 0
    !isempty(x.MimeType) && (encoded_size += PB._encoded_size(x.MimeType, 1))
    return encoded_size
end

struct UnixTime
    Seconds::Int64
    FractionalNanoseconds::UInt32
end
PB.default_values(::Type{UnixTime}) = (;Seconds = zero(Int64), FractionalNanoseconds = zero(UInt32))
PB.field_numbers(::Type{UnixTime}) = (;Seconds = 1, FractionalNanoseconds = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UnixTime})
    Seconds = zero(Int64)
    FractionalNanoseconds = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            Seconds = PB.decode(d, Int64)
        elseif field_number == 2
            FractionalNanoseconds = PB.decode(d, UInt32, Val{:fixed})
        else
            PB.skip(d, wire_type)
        end
    end
    return UnixTime(Seconds, FractionalNanoseconds)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UnixTime)
    initpos = position(e.io)
    x.Seconds != zero(Int64) && PB.encode(e, 1, x.Seconds)
    x.FractionalNanoseconds != zero(UInt32) && PB.encode(e, 2, x.FractionalNanoseconds, Val{:fixed})
    return position(e.io) - initpos
end
function PB._encoded_size(x::UnixTime)
    encoded_size = 0
    x.Seconds != zero(Int64) && (encoded_size += PB._encoded_size(x.Seconds, 1))
    x.FractionalNanoseconds != zero(UInt32) && (encoded_size += PB._encoded_size(x.FractionalNanoseconds, 2, Val{:fixed}))
    return encoded_size
end

struct Data
    var"#Type"::var"Data.DataType".T
    Data::Vector{UInt8}
    filesize::UInt64
    blocksizes::Vector{UInt64}
    hashType::UInt64
    fanout::UInt64
    mode::UInt32
    mtime::Union{Nothing,UnixTime}
end
PB.default_values(::Type{Data}) = (;var"#Type" = var"Data.DataType".Raw, Data = UInt8[], filesize = zero(UInt64), blocksizes = Vector{UInt64}(), hashType = zero(UInt64), fanout = zero(UInt64), mode = zero(UInt32), mtime = nothing)
PB.field_numbers(::Type{Data}) = (;var"#Type" = 1, Data = 2, filesize = 3, blocksizes = 4, hashType = 5, fanout = 6, mode = 7, mtime = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Data})
    var"#Type" = var"Data.DataType".Raw
    Data = UInt8[]
    filesize = zero(UInt64)
    blocksizes = PB.BufferedVector{UInt64}()
    hashType = zero(UInt64)
    fanout = zero(UInt64)
    mode = zero(UInt32)
    mtime = Ref{Union{Nothing,UnixTime}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#Type" = PB.decode(d, var"Data.DataType".T)
        elseif field_number == 2
            Data = PB.decode(d, Vector{UInt8})
        elseif field_number == 3
            filesize = PB.decode(d, UInt64)
        elseif field_number == 4
            PB.decode!(d, wire_type, blocksizes)
        elseif field_number == 5
            hashType = PB.decode(d, UInt64)
        elseif field_number == 6
            fanout = PB.decode(d, UInt64)
        elseif field_number == 7
            mode = PB.decode(d, UInt32)
        elseif field_number == 8
            PB.decode!(d, mtime)
        else
            PB.skip(d, wire_type)
        end
    end
    return Data(var"#Type", Data, filesize, blocksizes[], hashType, fanout, mode, mtime[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Data)
    initpos = position(e.io)
    x.var"#Type" != var"Data.DataType".Raw && PB.encode(e, 1, x.var"#Type")
    !isempty(x.Data) && PB.encode(e, 2, x.Data)
    x.filesize != zero(UInt64) && PB.encode(e, 3, x.filesize)
    !isempty(x.blocksizes) && PB.encode(e, 4, x.blocksizes)
    x.hashType != zero(UInt64) && PB.encode(e, 5, x.hashType)
    x.fanout != zero(UInt64) && PB.encode(e, 6, x.fanout)
    x.mode != zero(UInt32) && PB.encode(e, 7, x.mode)
    !isnothing(x.mtime) && PB.encode(e, 8, x.mtime)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Data)
    encoded_size = 0
    x.var"#Type" != var"Data.DataType".Raw && (encoded_size += PB._encoded_size(x.var"#Type", 1))
    !isempty(x.Data) && (encoded_size += PB._encoded_size(x.Data, 2))
    x.filesize != zero(UInt64) && (encoded_size += PB._encoded_size(x.filesize, 3))
    !isempty(x.blocksizes) && (encoded_size += PB._encoded_size(x.blocksizes, 4))
    x.hashType != zero(UInt64) && (encoded_size += PB._encoded_size(x.hashType, 5))
    x.fanout != zero(UInt64) && (encoded_size += PB._encoded_size(x.fanout, 6))
    x.mode != zero(UInt32) && (encoded_size += PB._encoded_size(x.mode, 7))
    !isnothing(x.mtime) && (encoded_size += PB._encoded_size(x.mtime, 8))
    return encoded_size
end
end # module
